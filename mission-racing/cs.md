## 레이어드 아키텍쳐란 
- 소프트웨어를 다양한 층으로 나누어 구축하는 설계 패턴.
- 상위 레이어는 하위 레이어의 서비스를 이용할 수 있음.
- 각 레이어가 책임을 가진다.

### 레이어드 아키텍쳐 구조

- 1. Presentation layer - 사용자 인터페이스 (view)
  2. Business layer - 핵심 비지니스 로직
  3. Persistence layer - 영속성 컨텍스트가 여기 속하나??
  4. Database layer - 데이터 소스 직접 다루는 층

### 결론

- 소프트웨어의 복잡성을 관리하고 구조를 명확히 하는데 도움을 줌.
- 효과적인 유지보수, 높은 재사용성, 유연한 설계패턴

---
## record 란? 

- ava Record는 bolierplate code를 줄이는 것을 목표로 하는 특별한 형태의 클래스 선언 방법.

### 구조

- public record TestRecord(String name, int age) {} : 일반적인 클래스와 다르게 선언과 함께 필드(컴포넌트)를 나열하여 선언

### 기능

- 상속 불가능 처리 (final class)
- 필드 private final 처리 및 Setter 미구현을 통한 불변성 제공
- Getter 구현
- equals() 구현
  - 일반 클래스는 주소 값을 비교하여 equals() 메서드 동작하지만, record 클래스는 이를 override 하여 모든 필드 값을 비교하도록 되어있음.
- hashCode() 구현
- toString() 구현

### Compact 생성자

- 표준 생성자와는 달리 컴팩트 생성자 내부에서는 인스턴스 필드에 접근할 수 없다는 특징이 있음. 따라서 validation으로 사용 가능.

---

## 스프링 동작 원리

### 스프링이란?

 - 자바 플랫폼을 위한 오픈소스 어플리케이션 프레임워크로, 엔터프라이즈급 어플리케이션을 개발하기 위한 모든 기능을 종합적으로 제공하는 경량화된 솔루션.(대규모 작업에 적합하다는 뜻.)
 - 이때, 다른 프레임워크와 다르게 멀티쓰레드 기반임. 이 말은 동시성 문제를 야기할 수 있다는 뜻.

### 스프링 프레임워크 특징

- IoC (Inversion of Control) : 제어의 역행 - 제어의 역행이라는 뜻으로, 소프트웨어 컴포넌트 간의 의존성 관리를 개선하는 디자인 패턴.
  - 스프링 어노테이션.md @Bean 과 @Component 차이점 보면 쉽게 이해 가능.

- DI (Dependency Injection) : 의존성 주입 - 의존성 객체를 개발자가 생성하지 않고 빈으로 등록해두면 스프링 프레임워크가 알아서 찾아 의존성 주입해줄 수 있음. 이를 통해 모듈간의 결합도를 낮출 수 있다.

- AOP (Aspect Oriented Programming) : 관점 지향 프로그래밍 - 핵심 로직 외의 부가적인 횡단 관심사를 모듈화하는 개념.

- POJO (Plane Old Java Object) : 평범한 자바 객체. 자바의 기본적인 객체 지향 프로그램 원칙을 따름.


### MVC 디자인 패턴

- Model : Model은 애플리케이션의 정보, 데이터의 가공을 책임지며 데이터베이스와 상호작용하여 비즈니스 로직을 처리하는 모듈임.
  - View(뷰) 또는 Controller(컨트롤러)에 대해 어떤 정보도 알 수 없어야 함.(의존성에 관한 것)
  - 모델은 재사용이 가능해야 하며 다른 인터페이스에서도 변하지 않아야 함.

- View : View는 클라이언트 단에서 보여지는 결과화면을 반환하는 모듈임.
  - Model(모델)이나 Controller(컨트롤러)에 대한 정보를 알면 안됨.
  - 데이터를 받아 단순히 화면에 표시해주는 역할만.

- Controller : Controller는 client로부터 request가 들어왔을 때 그 입력을 처리하고 어떤 로직을 실행시킬 것인지 Model(모델)과 View(뷰)를 연결해주며 제어하는 모듈임.
  - 모델이나 뷰의 변경 통지를 받으면 이를 해석해서 각각의 구성 요소에게 통지를 해야함.
  - 애플리케이션의 메인 로직을 담당.
---
## OS

### 멀티쓰레드는 소켓 통신(TCP)과 C언어 코드를 통해 이해했습니다.

서버란 : 클라이언트의 역할을 하는 프로세스와 소켓을 통해 IPC를 수행하는 것

소켓: TCP소켓(=stream), UDP소켓(=datagram)으로 나뉨

[동작과정]

![TCP 소켓을 사용하는 흐름](서버통신.png)

[TCP 소켓을 사용하는 흐름]

<aside>
💡 TCP 소켓의 핵심은 **accept() 시스템 콜**

</aside>

1. socket() 시스템 콜: 소켓을 만드는 시스템 콜, 미리 형태를 잡아두는 것 / 파일 디스크립터 형식으로 반환. 
- 형식: socket(IPV6, stream, 6(=TCP))

---

2. bind() 시스템 콜: 생성한 소켓에 실제 아이피 주소와 포트 번호 매기는 것(클라이언트는 포트 번호 자동 생성) / bind()시스템 콜은 서버에서만 사용

- 형식: bind(sockfd, sockaddr, socklen_t)
  - sockfd: 바인딩 할 소켓의 파일 디스크립터
  - sockaddr: 소켓에 바인딩 할 아이피 주소, 포트번호를 담은 구조체
  - socklen_t: 위 구조체의 메모리 크기

---

3. listen() 시스템 콜: 연결요청을 대기하는 함수 / Only for TCP

- 파라미터로 받은 backlog 크기만큼 backlog queue를 만드는 시스템 콜!(클라이언트 대기실)
  - 형식: listen(sockfd, backlog)

**서버의 listen 이후  Client의 connect() 시스템 콜 요청: SYN 던짐

---

4. accept() 시스템 콜: 연결요청 수락 함수 / 반환값은 새로운 디스크립트 번호 = ***accept() 함수를 통해 새로 할당받은 소켓을 이용해 데이터 송,수신을 할 수 있는 것***


    왜 새로운 소켓 생성? 
    
    SYN 요청을 보낸 클라이언트가 적어도 하나 있어서 백로그 큐에 있었고 해당 클라이언트의 요청에 대한 이후 응답을 위해 **새로운 소켓을 만들었다.**
    
    형식: int accept(sockfd, sockaddr, socklen_t);
    
    이 listen 시스템 콜이 설정된 이후에 클라이언트의 connect() 요청을 받을 수 있는데, 하나 하나 accept() 해주면 병목 발생 → 멀티 프로세스/ 멀티 쓰레드 이용 : **연결 요청을 받는 부분 따로, 이후 응답까지 주는 부분을 따로 나누게 된다.**
    
    멀티프로세스:  컨텍스트 스위칭을 통해 일어남. 부모에 해당하는 프로세스 작업을 이어오다가, 새로운 자식프로세스를 생성하고 싶은 순간 fork() 함수 호출 
    
    i)fork() == 0: 자식 프로세스 / **마지막에 exit(0) 시스템 콜을 호출(=새로운 응답 안받고 그냥 종료)**
    
    ii) fork() ≠ 0 : 부모 프로세스
    
    이 fork() 함수를 통해 병렬처리를 진행할 수 있다.
    
    멀티 쓰레드:  fork()함수 통해 생성. 프로세스 생성하기 부담스럽고, 컨텍스트 스위칭 하는게 멀티프로세스에서보다 빨라서 만들어짐. 자원을 공유하기 때문에 필연적으로**동시화 문제**가 발생할 수 밖에 없다. 교착상태가 발생하지 않도록 주의해야 한다.
    
    **accept() 시스템 콜 이후에 잔여 3-Way-Handshaking 진행: SYN+ACK → ACK ⇒ Established

<aside>
📢 **서버는 연결을 받는 부분과 응답을 주는 부분이 병렬적으로 이루어져 있다**

</aside>)

- 스프링은 멀티쓰레드 기반이라서 동시 요청에 대해 안전하지가 않다. 즉 필드에 객체나 변수가 선언되면 여러 쓰레드가 접근할 수 있다. 노드는 하나의 쓰레드가 순차적으로 처리되지만 스프링은 그렇지 않다.
  컴퓨터가 자원을 읽을 때 현재 상태를 읽고 값을 바꾸는데 멀티스레드 기반에서 동시에 요청이 오면 값의 일관성이 없어진다.

  - 예를 들어 게시글 좋아요가 100개인 상태에서 동시에 2명이 좋아요를 눌렀을 때 102개가 되어야 하지만 101개가 될 수도 있다는 뜻이다 두 쓰레드가 조회 시점에 100을 읽기 때문에 변경된 값이 적용되지 않는다.

---
## CustomException

### 개요
- 개발을 하다 보면 수많은 Exception 을 만남. 이때, Exception 발생하는 부분을 쉽게 알아채고 코드를 수정하기 위해 CustomException 사용.

### 방법
- 총 4가지의 클래스 존재
  1. CustomErrorCode : Exception이 발생하였을때 알려준 Status 상태와 메시지를 담은 enum 클래스
  2. CustomErrorResponse : 일종의 dto
  3. CustomException : RuntimeException을 상속받은 클래스
  4. CustomExceptionHandler : 일종의 Exception Controller
  
---

## Checked exception vs Unchecked exception

### 자바의 예외처리는 크게 3가지로 나눌 수 있다.

- 에러
  - 시스템에 비정상적인 상황이 발생했을 경우에 발생.
  - 메모리 부족(OutofMemoryError)이나 스택오버플로우(StackOverflowError)와 같이 복구할 수 없는 것.

- 체크 예외
  - RuntimeException의 하위 클래스가 아니면서 Exception 클래스의 하위 클래스.
  - ex) 존재하지 않는 파일의 이름을 입력(FileNotFoundException), 실수로 클래스의 이름을 잘못 적음(ClassNotFoundException)
  - 반드시 예외 처리 함.
  - Rollback이 되지 않고, 트랜젝션이 commit까지 완료.
  
- 언체크 예외
  - RuntimeException의 하위 클래스, 실행 중에 발생할 수 있는 에러.
  - ex) 배열의 범위를 벗어난(ArrayIndexOutOfBoundsException), 값이 null이 참조변수를 참조(NullPointerException)
  - 명시적인 예외처리 강제하지 않음.
  - Rollback 함.

---
## 직렬화와 역직렬화

### 직렬화란?

- 객체들의 데이터를 연속적인 데이터(스트림)로 변형하여 전송 가능한 형태로 만드는 것.

### 역직렬화란? 

- 직렬화된 데이터를 다시 객체의 형태로 만드는 것.
  
더 공부 필요..
