## 레이어드 아키텍쳐란 
- 소프트웨어를 다양한 층으로 나누어 구축하는 설계 패턴.
- 상위 레이어는 하위 레이어의 서비스를 이용할 수 있음.
- 각 레이어가 책임을 가진다.

### 레이어드 아키텍쳐 구조

- 1. Presentation layer - 사용자 인터페이스 (view)
  2. Business layer - 핵심 비지니스 로직
  3. Persistence layer - 영속성 컨텍스트가 여기 속하나??
  4. Database layer - 데이터 소스 직접 다루는 층

### 결론

- 소프트웨어의 복잡성을 관리하고 구조를 명확히 하는데 도움을 줌.
- 효과적인 유지보수, 높은 재사용성, 유연한 설계패턴

---

## 스프링 동작 원리

### 스프링이란?

 - 자바 플랫폼을 위한 오픈소스 어플리케이션 프레임워크로, 엔터프라이즈급 어플리케이션을 개발하기 위한 모든 기능을 종합적으로 제공하는 경량화된 솔루션.(대규모 작업에 적합하다는 뜻.)
 - 이때, 다른 프레임워크와 다르게 멀티쓰레드 기반임. 이 말은 동시성 문제를 야기할 수 있다는 뜻.

### 스프링 프레임워크 특징

- IoC (Inversion of Control) : 제어의 역행 - 제어의 역행이라는 뜻으로, 소프트웨어 컴포넌트 간의 의존성 관리를 개선하는 디자인 패턴.
  - 스프링 어노테이션.md @Bean 과 @Component 차이점 보면 쉽게 이해 가능.

- DI (Dependency Injection) : 의존성 주입 - 의존성 객체를 개발자가 생성하지 않고 빈으로 등록해두면 스프링 프레임워크가 알아서 찾아 의존성 주입해줄 수 있음. 이를 통해 모듈간의 결합도를 낮출 수 있다.

- AOP (Aspect Oriented Programming) : 관점 지향 프로그래밍 - 핵심 로직 외의 부가적인 횡단 관심사를 모듈화하는 개념.

- POJO (Plane Old Java Object) : 평범한 자바 객체. 자바의 기본적인 객체 지향 프로그램 원칙을 따름.


### MVC 디자인 패턴

- Model : Model은 애플리케이션의 정보, 데이터의 가공을 책임지며 데이터베이스와 상호작용하여 비즈니스 로직을 처리하는 모듈임.
  - View(뷰) 또는 Controller(컨트롤러)에 대해 어떤 정보도 알 수 없어야 함.(의존성에 관한 것)
  - 모델은 재사용이 가능해야 하며 다른 인터페이스에서도 변하지 않아야 함.

- View : View는 클라이언트 단에서 보여지는 결과화면을 반환하는 모듈임.
  - Model(모델)이나 Controller(컨트롤러)에 대한 정보를 알면 안됨.
  - 데이터를 받아 단순히 화면에 표시해주는 역할만.

- Controller : Controller는 client로부터 request가 들어왔을 때 그 입력을 처리하고 어떤 로직을 실행시킬 것인지 Model(모델)과 View(뷰)를 연결해주며 제어하는 모듈임.
  - 모델이나 뷰의 변경 통지를 받으면 이를 해석해서 각각의 구성 요소에게 통지를 해야함.
  - 애플리케이션의 메인 로직을 담당.
---
## OS

### 멀티쓰레드는 소켓 통신(TCP)과 C언어 코드를 통해 이해했습니다.

서버란 : 클라이언트의 역할을 하는 프로세스와 소켓을 통해 IPC를 수행하는 것

소켓: TCP소켓(=stream), UDP소켓(=datagram)으로 나뉨

[동작과정]

![TCP 소켓을 사용하는 흐름](서버통신.png)

[TCP 소켓을 사용하는 흐름]

<aside>
💡 TCP 소켓의 핵심은 **accept() 시스템 콜**

</aside>

1. socket() 시스템 콜: 소켓을 만드는 시스템 콜, 미리 형태를 잡아두는 것 / 파일 디스크립터 형식으로 반환. 
- 형식: socket(IPV6, stream, 6(=TCP))

---

2. bind() 시스템 콜: 생성한 소켓에 실제 아이피 주소와 포트 번호 매기는 것(클라이언트는 포트 번호 자동 생성) / bind()시스템 콜은 서버에서만 사용

- 형식: bind(sockfd, sockaddr, socklen_t)

sockfd: 바인딩 할 소켓의 파일 디스크립터

sockaddr: 소켓에 바인딩 할 아이피 주소, 포트번호를 담은 구조체

socklen_t: 위 구조체의 메모리 크기

---

3. listen() 시스템 콜: 연결요청을 대기하는 함수 / Only for TCP

파라미터로 받은 backlog 크기만큼 backlog queue를 만드는 시스템 콜!(클라이언트 대기실)

형식: listen(sockfd, backlog)

**서버의 listen 이후  Client의 connect() 시스템 콜 요청: SYN 던짐

---

4. accept() 시스템 콜: 연결요청 수락 함수 / 반환값은 새로운 디스크립트 번호 = ***accept() 함수를 통해 새로 할당받은 소켓을 이용해 데이터 송,수신을 할 수 있는 것***


    왜 새로운 소켓 생성? 
    
    SYN 요청을 보낸 클라이언트가 적어도 하나 있어서 백로그 큐에 있었고 해당 클라이언트의 요청에 대한 이후 응답을 위해 **새로운 소켓을 만들었다.**
    
    형식: int accept(sockfd, sockaddr, socklen_t);
    
    이 listen 시스템 콜이 설정된 이후에 클라이언트의 connect() 요청을 받을 수 있는데, 하나 하나 accept() 해주면 병목 발생 → 멀티 프로세스/ 멀티 쓰레드 이용 : **연결 요청을 받는 부분 따로, 이후 응답까지 주는 부분을 따로 나누게 된다.**
    
    멀티프로세스:  컨텍스트 스위칭을 통해 일어남. 부모에 해당하는 프로세스 작업을 이어오다가, 새로운 자식프로세스를 생성하고 싶은 순간 fork() 함수 호출 
    
    i)fork() == 0: 자식 프로세스 / **마지막에 exit(0) 시스템 콜을 호출(=새로운 응답 안받고 그냥 종료)**
    
    ii) fork() ≠ 0 : 부모 프로세스
    
    이 fork() 함수를 통해 병렬처리를 진행할 수 있다.
    
    멀티 쓰레드:  fork()함수 통해 생성. 프로세스 생성하기 부담스럽고, 컨텍스트 스위칭 하는게 멀티프로세스에서보다 빨라서 만들어짐. 자원을 공유하기 때문에 필연적으로**동시화 문제**가 발생할 수 밖에 없다. 교착상태가 발생하지 않도록 주의해야 한다.
    
    **accept() 시스템 콜 이후에 잔여 3-Way-Handshaking 진행: SYN+ACK → ACK ⇒ Established

<aside>
📢 **서버는 연결을 받는 부분과 응답을 주는 부분이 병렬적으로 이루어져 있다**

</aside>)


